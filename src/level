action_safe.c: * This file handles non-fighting player actions.
action_safe.c:  snprintf(buf, MAX_BUFFER, "%s has left the game.", dMob->name);
action_safe.c:  dMob->socket->player = NULL;
action_safe.c:  close_socket(dMob->socket, FALSE);
action_safe.c:  bprintf(buf, "    - - - - ----==== The full command list ====---- - - - -\n\n\r");
action_safe.c:    if (dMob->level < tabCmd[i].level) continue;
action_safe.c:    bprintf(buf, " %-16.16s", tabCmd[i].cmd_name);
action_safe.c:  text_to_mobile(dMob, buf->data);
action_safe.c:  bprintf(buf, " - - - - ----==== Who's Online ====---- - - - -\n\r");
action_safe.c:    if (dsock->state != STATE_PLAYING) continue;
action_safe.c:    if ((xMob = dsock->player) == NULL) continue;
action_safe.c:    bprintf(buf, " %-12s   %s\n\r", xMob->name, dsock->hostname);
action_safe.c:  bprintf(buf, " - - - - ----======================---- - - - -\n\r");
action_safe.c:  text_to_mobile(dMob, buf->data);
action_safe.c:    bprintf(buf, "      - - - - - ----====//// HELP FILES  \\\\\\\\====---- - - - - -\n\n\r");
action_safe.c:      bprintf(buf, " %-19.18s", pHelp->keyword);
action_safe.c:    text_to_mobile(dMob, buf->data);
action_safe.c:  if (!dMob->socket)
action_safe.c:  if (!dMob->socket->out_compress)
action_safe.c:    text_to_buffer(dMob->socket, (char *) compress_will2);
action_safe.c:    text_to_buffer(dMob->socket, (char *) compress_will);
action_safe.c:    if (!compressEnd(dMob->socket, dMob->socket->compressing, FALSE))
action_safe.c:         ".-------------------[ IdentiCorp Identification System ]--------------------.\r\n"
action_safe.c:         "| .-[ IDENTIFICATION ]---------.  .-[ STATS ]----------------------.        |\r\n"
action_safe.c:         "| '----------------------------'  | Stamina:                   %3i |        |\r\n"
action_safe.c:         "| .-[ BIO. INFORMATION ]-------.  | Luck:                      %3i |        |\r\n"
action_safe.c:         "| '----------------------------'  '--------------------------------'",
action_safe.c:         dMob->name, dMob->brains, dMob->gender == FEMALE ? "female" : dMob->gender == MALE ? "male" : "nonbinary",
action_safe.c:         dMob->brawn, "synthetic", dMob->speed, "94F3DD21", dMob->senses, dMob->stamina, dMob->luck,
action_safe.c:         "None", dMob->cool, "BitCorp", 1.9, 3.100023, 81 );
action_safe.c:   text_to_socket( dMob->socket, buf );
action_safe.c:         "| .-[ VITALS ]-----------------.  .-[ NETSTAT ]--------------------.        |\r\n"
action_safe.c:         "| '----------------------------'   imprisonment, and/or death.              |\r\n"
action_safe.c:         "'---------------------------------------------------------------------------'\r\n" );
action_safe.c:   text_to_socket( dMob->socket, buf );
action_safe.c:    compressEnd(dsock, dsock->compressing, FALSE);
action_safe.c:    if (dsock->state != STATE_PLAYING)
action_safe.c:        dsock->control, dsock->player->name, dsock->hostname);
action_safe.c:      save_player(dsock->player);
action_safe.c:  fprintf (fp, "-1\n");
action_safe.c:  /* Failed - sucessful exec will not return */
action_safe.c:    if (!xMob->socket)
action_safe.c:      snprintf(buf, MAX_BUFFER, "%s is linkdead.\n\r", xMob->name);
comm.c:   int iBlck, iPtr, iWrt = 0, length, icontrol = dsock->control;
comm.c:   if( dsock && dsock->out_compress )
comm.c:      dsock->out_compress->next_in = (unsigned char *)txt;
comm.c:      dsock->out_compress->avail_in = length;
comm.c:      while( dsock->out_compress->avail_in )
comm.c:         dsock->out_compress->avail_out = COMPRESS_BUF_SIZE - ( dsock->out_compress->next_out - dsock->out_compress_buf );
comm.c:         if( dsock->out_compress->avail_out )
comm.c:            int status = deflate( dsock->out_compress, Z_SYNC_FLUSH );
comm.c:         length = dsock->out_compress->next_out - dsock->out_compress_buf;
comm.c:               iBlck = UMIN( length - iPtr, 4096 );
comm.c:               if( ( iWrt = write( icontrol, dsock->out_compress_buf + iPtr, iBlck ) ) < 0 )
comm.c:                  memmove( dsock->out_compress_buf, dsock->out_compress_buf + iPtr, length - iPtr );
comm.c:               dsock->out_compress->next_out = dsock->out_compress_buf + length - iPtr;
comm.c:      iBlck = UMIN( length - iPtr, 4096 );
comm.c:   if( dsock->top_output == 0 )
comm.c:      dsock->outbuf[0] = '\n';
comm.c:      dsock->outbuf[1] = '\r';
comm.c:      dsock->top_output = 2;
comm.c:   if( dsock->top_output + strlen(output) >= MAX_OUTPUT )
comm.c:      bug( "Text_to_buffer: ouput overflow on %s.", dsock->hostname );
comm.c:   strncat( dsock->outbuf, output, MAX_OUTPUT - strlen( dsock->outbuf ) -1 );
comm.c:   dsock->top_output = strlen( dsock->outbuf );
comm.c:   if( dMob->socket )
comm.c:      text_to_buffer( dMob->socket, txt );
comm.c:      dMob->socket->bust_prompt = TRUE;
comm.c:      snprintf(message, MAX_BUFFER, "&o%s says '%s'.\n\r", dMob->name, txt);
comm.c:   if( dsock->outbuf[0] == '\0' && !( dsock->bust_prompt && dsock->state == STATE_PLAYING ) )
comm.c:   if( dsock->state == STATE_PLAYING && dsock->bust_prompt )
comm.c:      text_to_buffer( dsock, "\r\n\r\n%s", parse_prompt( dsock->player ) );
comm.c:      dsock->bust_prompt = FALSE;
comm.c:   if( dsock->account && dsock->account->acceptANSI == TRUE )
comm.c:      text_to_socket( dsock, "%s\r\n", parse_color_codes( dsock->outbuf ) );
comm.c:   else if( dsock->account && dsock->account->acceptANSI == FALSE )
comm.c:      text_to_socket( dsock, "%s\r\n",  strip_color_codes( dsock->outbuf ) );
comm.c:      text_to_socket( dsock, "%s\r\n",  dsock->outbuf );
comm.c:   dsock->outbuf[0] = '\0';
comm.c:   if( !dMob->prompt )
comm.c:      dMob->prompt = strdup( "<&Y$h&W/&Y$Hhp&W>" );
comm.c:   orig  = dMob->prompt;
comm.c:               start += sprintf( start, "%i", dMob->cur_hp );
comm.c:               start += sprintf( start, "%i", dMob->max_hp );
event.c:  event->fun = &event_game_tick;
event.c:  event->type = EVENT_GAME_TICK;
event.c:   * it's the safest - and post a bug message.
event.c:  if ((dMob = event->owner.dMob) == NULL)
event.c:  event->fun = &event_mobile_save;
event.c:  event->type = EVENT_MOBILE_SAVE;
event.c:   * it's the safest - and post a bug message.
event.c:  if ((dSock = event->owner.dSock) == NULL)
event-handler.c:  if (event->ownertype == EVENT_UNOWNED)
event-handler.c:    bug("enqueue_event: event type %d with no owner.", event->type);
event-handler.c:  event->passes = passes;
event-handler.c:  event->bucket = bucket;
event-handler.c:  DetachFromList(event, eventqueue[event->bucket]);
event-handler.c:  switch(event->ownertype)
event-handler.c:      bug("dequeue_event: event type %d has no owner.", event->type);
event-handler.c:      DetachFromList(event, event->owner.dMob->events);
event-handler.c:      DetachFromList(event, event->owner.dSock->events);
event-handler.c:  free(event->argument);
event-handler.c:  event->fun        = NULL;
event-handler.c:  event->argument   = NULL;
event-handler.c:  event->owner.dMob = NULL;  /* only need to NULL one of the union members */
event-handler.c:  event->passes     = 0;
event-handler.c:  event->bucket     = 0;
event-handler.c:  event->ownertype  = EVENT_UNOWNED;
event-handler.c:  event->type       = EVENT_NONE;
event-handler.c:    event->fun = &event_game_tick;
event-handler.c:    event->type = EVENT_GAME_TICK;
event-handler.c:    /* Here we use the event->passes integer, to keep track of
event-handler.c:    if (event->passes-- > 0) continue;
event-handler.c:    if (!((*event->fun)(event)))
event-handler.c:  if (event->type == EVENT_NONE)
event-handler.c:  if (event->fun == NULL)
event-handler.c:    bug("add_event_mobile: event type %d has no callback function.", event->type);
event-handler.c:  event->ownertype  = EVENT_OWNER_DMOB;
event-handler.c:  event->owner.dMob = dMob;
event-handler.c:  AttachToList(event, dMob->events);
event-handler.c:    bug("add_event_mobile: event type %d failed to be enqueued.", event->type);
event-handler.c:  if (event->type == EVENT_NONE)
event-handler.c:  if (event->fun == NULL)
event-handler.c:    bug("add_event_socket: event type %d has no callback function.", event->type);
event-handler.c:  event->ownertype   = EVENT_OWNER_DSOCKET;
event-handler.c:  event->owner.dSock = dSock;
event-handler.c:  AttachToList(event, dSock->events);
event-handler.c:    bug("add_event_socket: event type %d failed to be enqueued.", event->type);
event-handler.c:  if (event->type == EVENT_NONE)
event-handler.c:  if (event->fun == NULL)
event-handler.c:    bug("add_event_game: event type %d has no callback function.", event->type);
event-handler.c:  event->ownertype = EVENT_OWNER_GAME;
event-handler.c:    bug("add_event_game: event type %d failed to be enqueued.", event->type);
event-handler.c:  AttachIterator(&Iter, dSock->events);
event-handler.c:    if (event->type == type)
event-handler.c:  AttachIterator(&Iter, dMob->events);
event-handler.c:    if (event->type == type)
event-handler.c:  AttachIterator(&Iter, dSock->events);
event-handler.c:    if (event->type == type)
event-handler.c:  AttachIterator(&Iter, dMob->events);
event-handler.c:    if (event->type == type)
event-handler.c:  event->fun = &event_mobile_save;
event-handler.c:  event->type = EVENT_MOBILE_SAVE;
event-handler.c:  event->fun = &event_socket_idle;
event-handler.c:  event->type = EVENT_SOCKET_IDLE;
handler_connections.c:                        "---------\r\n"
handler_connections.c:   switch(dsock->state)
handler_connections.c:         bug("Handle_new_connections: Bad state %i", (int)dsock->state );
handler_connections.c:            text_to_buffer( dsock, "Please enter an e-mail address to create an account: " );
handler_connections.c:            dsock->state = STATE_NEW_ACCOUNT;
handler_connections.c:         snprintf( dsock->loginName, MAX_BUFFER, "%s", arg );
handler_connections.c:         dsock->state = STATE_ASK_PASSWORD;
handler_connections.c:         if( ( dsock->account = load_account( dsock->loginName,arg ) ) == NULL )
handler_connections.c:            dsock->state = STATE_GET_ACCOUNT;
handler_connections.c:         dsock->state = STATE_MAIN_MENU;
handler_connections.c:               text_to_buffer( dsock, "Please make a valid selection (1-6).\r\n" );
handler_connections.c:               if( dsock->account->characters == NULL )
handler_connections.c:                  AttachIterator(&Iter, dsock->account->characters );
handler_connections.c:               text_to_buffer( dsock, "--== Character Creation ==--\r\n" );
handler_connections.c:                                      "Your choice of a name affects your character, how you can role-play,\r\n"
handler_connections.c:               dsock->state = STATE_CHARGEN_NAME;
handler_connections.c:               dsock->state = STATE_MAIN_MENU;
handler_connections.c:               if( ( dsock->player = load_player( name ) ) == NULL )
handler_connections.c:               log_string("Player: %s has entered the game.", dsock->player->name);
handler_connections.c:               dsock->player->socket = dsock;
handler_connections.c:               AttachToList(dsock->player, dmobile_list);
handler_connections.c:               init_events_player(dsock->player);
handler_connections.c:               dsock->state = STATE_PLAYING;
handler_connections.c:               cmd_look( dsock->player, "" );
handler_connections.c:         if( dsock->player && dsock->player->name )
handler_connections.c:            free( dsock->player->name );
handler_connections.c:            free( dsock->player );
handler_connections.c:            dsock->state = STATE_MAIN_MENU;
handler_connections.c:         if( ( dsock->player = malloc( sizeof( D_MOBILE ) ) ) == NULL )
handler_connections.c:            dsock->state = STATE_CLOSED;
handler_connections.c:         dsock->player->name = strdup( arg );
handler_connections.c:         //snprintf( dsock->player->name, MAX_PC_NAME_LENGTH, "%s", arg );
handler_connections.c:         text_to_socket( dsock, "Input \"%s\" is accepted.\r\n", dsock->player->name );
handler_connections.c:         text_to_socket( dsock, "Specify personnel gender. [M]ale, [F]emale, [N]onbinary", dsock->player->name );
handler_connections.c:         dsock->state = STATE_CHARGEN_GENDER;
handler_connections.c:               dsock->player->gender = MALE;
handler_connections.c:               dsock->player->gender = FEMALE;
handler_connections.c:               dsock->player->gender = NONBINARY;
handler_connections.c:               dsock->state = STATE_MAIN_MENU;
handler_connections.c:         dsock->player->level = 4;
handler_connections.c:         dsock->player->prompt = strdup( "<&Y$h&W/&Y$Hhp&W>" );
handler_connections.c:         log_string("Player: %s has entered the game.", dsock->player->name);
handler_connections.c:         dsock->player->socket = dsock;
handler_connections.c:         AttachToList(dsock->player, dmobile_list);
handler_connections.c:         init_events_player(dsock->player);
handler_connections.c:         dsock->state = STATE_PLAYING;
handler_json.c:   account->characters = NULL;
handler_json.c:         account->email = strdup( json_string_value( value ) );
handler_json.c:         account->password = strdup( json_string_value( value ) );
handler_json.c:            account->characters = l;
help.c:    if (is_prefix(helpfile, pHelp->keyword))
help.c:    if (last_modified(hFile) > pHelp->load_time)
help.c:      free(pHelp->text);
help.c:      pHelp->text = strdup(read_help_entry(hFile));
help.c:      pHelp->keyword    =  strdup(hFile);
help.c:      pHelp->text       =  strdup(entry);
help.c:      pHelp->load_time  =  time(NULL);
help.c:  snprintf(buf, MAX_HELP_ENTRY + 80, "=== %s ===\n\r%s", pHelp->keyword, pHelp->text);
help.c:    if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
help.c:    snprintf(buf, MAX_BUFFER, "../help/%s", entry->d_name);
help.c:    new_help->keyword    =  strdup(entry->d_name);
help.c:    new_help->text       =  strdup(s);
help.c:    new_help->load_time  =  time(NULL);
help.c:    if (!strcasecmp("GREETING", new_help->keyword))
help.c:      greeting = new_help->text;
help.c:    else if (!strcasecmp("MOTD", new_help->keyword))
help.c:      motd = new_help->text;
interpret.c:  if ((dMob = dsock->player) == NULL)
interpret.c:    if (tabCmd[i].level > dMob->level) continue;
interpret.c: /* --------------------------------------------- */
io.c:    if (++ptr > MAX_HELP_ENTRY - 2)
io.c:    if (++entry > MAX_BUFFER - 1)
io.c: * the value as an integer, a leading '-' will
io.c: * is the only non-digit that the function
io.c:  else if (c == '-')
io.c:    number = c - '0';
io.c:    number = number * 10 + c - '0';
io.c:  /* push back the non-digit */
io.c:  return (negative ? (0 - number) : number);
io.c:    if (++count > (4 * MAX_BUFFER - 2))
io.c:    bug("Fread_string: Non-fatal error, encountered EOF instead of ~.");
io.c:    if (++count > MAX_BUFFER - 1)
list.c: * The implementation of a basic double-linked list
list.c:  pList->_pFirstCell = NULL;
list.c:  pList->_pLastCell = NULL;
list.c:  pList->_iterators = 0;
list.c:  pList->_valid = 1;
list.c:  pList->_size = 0;
list.c:  pIter->_pList = pList;
list.c:    pList->_iterators++;
list.c:    pIter->_pCell = pList->_pFirstCell;
list.c:    pIter->_pCell = NULL;
list.c:  pCell->_pNextCell = NULL;
list.c:  pCell->_pPrevCell = NULL;
list.c:  pCell->_pContent = NULL;
list.c:  pCell->_valid = 1;
list.c:  for (pCell = pList->_pFirstCell; pCell != NULL; pCell = pCell->_pNextCell)
list.c:    if (pCell && !pCell->_valid)
list.c:    if (pCell->_pContent == pContent)
list.c:  pCell->_pContent = pContent;
list.c:  pCell->_pNextCell = pList->_pFirstCell;
list.c:  if (pList->_pFirstCell != NULL)
list.c:    pList->_pFirstCell->_pPrevCell = pCell;
list.c:  if (pList->_pLastCell == NULL)
list.c:    pList->_pLastCell = pCell;
list.c:  pList->_pLastCell->_pNextCell = NULL;
list.c:  pList->_pFirstCell = pCell;
list.c:  pList->_size++;
list.c:  for (pCell = pList->_pFirstCell; pCell != NULL; pCell = pCell->_pNextCell)
list.c:    if (pCell->_pContent == pContent)
list.c:      if (pList->_iterators > 0)
list.c:      pList->_size--;
list.c:  LIST *pList = pIter->_pList;
list.c:    pList->_iterators--;
list.c:    if (pList->_iterators <= 0)
list.c:      for (pCell = pList->_pFirstCell; pCell != NULL; pCell = pNextCell)
list.c:        pNextCell = pCell->_pNextCell;
list.c:        if (!pCell->_valid)
list.c:      if (!pList->_valid)
list.c:  if (pList->_iterators > 0)
list.c:    pList->_valid = 0;
list.c:  for (pCell = pList->_pFirstCell; pCell != NULL; pCell = pNextCell)
list.c:    pNextCell = pCell->_pNextCell;
list.c:  if (pList->_pFirstCell == pCell)
list.c:    pList->_pFirstCell = pCell->_pNextCell;
list.c:  if (pList->_pLastCell == pCell)
list.c:    pList->_pLastCell = pCell->_pPrevCell;
list.c:  if (pCell->_pPrevCell != NULL)
list.c:    pCell->_pPrevCell->_pNextCell = pCell->_pNextCell;
list.c:  if (pCell->_pNextCell != NULL) 
list.c:    pCell->_pNextCell->_pPrevCell = pCell->_pPrevCell;
list.c:  pCell->_valid = 0;
list.c:  while (pIter->_pCell != NULL && !pIter->_pCell->_valid)
list.c:    pIter->_pCell = pIter->_pCell->_pNextCell;
list.c:  if (pIter->_pCell != NULL)
list.c:    pContent = pIter->_pCell->_pContent;
list.c:    pIter->_pCell = pIter->_pCell->_pNextCell;
list.c:  return pList->_size;
mccp.c: * mccp.c - support functions for the Mud Client Compression Protocol
mccp.c: * Memory management - zlib uses these hooks to allocate and free memory
mccp.c:  if (dsock->out_compress)
mccp.c:  dsock->out_compress_buf = (unsigned char *) malloc(COMPRESS_BUF_SIZE);
mccp.c:  s->next_in    =  NULL;
mccp.c:  s->avail_in   =  0;
mccp.c:  s->next_out   =  dsock->out_compress_buf;
mccp.c:  s->avail_out  =  COMPRESS_BUF_SIZE;
mccp.c:  s->zalloc     =  zlib_alloc;
mccp.c:  s->zfree      =  zlib_free;
mccp.c:  s->opaque     =  NULL;
mccp.c:    free(dsock->out_compress_buf);
mccp.c:    free(dsock->out_compress_buf);
mccp.c:  dsock->compressing = teleopt;
mccp.c:  dsock->out_compress = s;
mccp.c:  if (!dsock->out_compress)
mccp.c:  if (dsock->compressing != teleopt)
mccp.c:  dsock->out_compress->avail_in = 0;
mccp.c:  dsock->out_compress->next_in = dummy;
mccp.c:  dsock->top_output = 0;
mccp.c:  /* No terminating signature is needed - receiver will get Z_STREAM_END */
mccp.c:  if (deflate(dsock->out_compress, Z_FINISH) != Z_STREAM_END && !forced)
mccp.c:  deflateEnd(dsock->out_compress);
mccp.c:  free(dsock->out_compress_buf);
mccp.c:  free(dsock->out_compress);
mccp.c:  dsock->compressing      = 0;
mccp.c:  dsock->out_compress     = NULL;
mccp.c:  dsock->out_compress_buf = NULL;
mccp.c:/* Try to send any pending compressed-but-not-sent data in `desc' */
mccp.c:  if (!dsock->out_compress)
mccp.c:  len = dsock->out_compress->next_out - dsock->out_compress_buf;
mccp.c:      nBlock = UMIN (len - iStart, 4096);
mccp.c:      if ((nWrite = write(dsock->control, dsock->out_compress_buf + iStart, nBlock)) < 0)
mccp.c:        memmove(dsock->out_compress_buf, dsock->out_compress_buf+iStart, len - iStart);
mccp.c:      dsock->out_compress->next_out = dsock->out_compress_buf + len - iStart;
save.c:   dMob->events = AllocList();
save.c:         dMob->name = strdup( json_string_value( value ) );
save.c:         dMob->level = json_integer_value( value );
save.c:            dMob->gender = FEMALE;
save.c:            dMob->gender = MALE;
save.c:            dMob->gender = NONBINARY;
save.c:         dMob->brains = json_integer_value( value );
save.c:         dMob->brawn = json_integer_value( value );
save.c:         dMob->speed = json_integer_value( value );
save.c:         dMob->senses = json_integer_value( value );
save.c:         dMob->stamina = json_integer_value( value );
save.c:         dMob->luck = json_integer_value( value );
save.c:         dMob->cool = json_integer_value( value );
save.c:         dMob->cur_hp = json_integer_value( value );
save.c:         dMob->max_hp = json_integer_value( value );
save.c:   snprintf( filename, MAX_BUFFER, "../players/%c/%s.dat", toupper(dMob->name[0]), dMob->name );
save.c:   json_object_set_new( json, "name", json_string( dMob->name ) );
save.c:   json_object_set_new( json, "level", json_integer( dMob->level ) );
save.c:   json_object_set_new( json, "gender", json_string( dMob->gender == FEMALE ? "female" : dMob->gender == MALE ? "male" : "nonbinary" ) );
save.c:   json_object_set_new( json, "brains", json_integer( dMob->brains ) );
save.c:   json_object_set_new( json, "brawn", json_integer( dMob->brawn ) );
save.c:   json_object_set_new( json, "speed", json_integer( dMob->speed) );
save.c:   json_object_set_new( json, "senses", json_integer( dMob->senses) );
save.c:   json_object_set_new( json, "stamina", json_integer( dMob->stamina) );
save.c:   json_object_set_new( json, "luck", json_integer( dMob->luck) );
save.c:   json_object_set_new( json, "cool", json_integer( dMob->cool) );
save.c:   json_object_set_new( json, "cur_hp", json_integer( dMob->cur_hp ) );
save.c:   json_object_set_new( json, "max_hp", json_integer( dMob->max_hp ) );
save.c:  if( json_dump_file( json, filename, JSON_INDENT(3)|JSON_SORT_KEYS ) == -1 )
save.c:     bug( "Error writing profile %s", dMob->name );
socket.c:  /* initialize the event queue - part 1 */
socket.c:  if (argc > 2 && !strcmp(argv[argc-1], "copyover") && atoi(argv[argc-2]) > 0)
socket.c:    control = atoi(argv[argc-2]);
socket.c:  /* initialize the event queue - part 2*/
socket.c:    FD_SET(dsock->control, &fSet);
socket.c:      if (FD_ISSET(dsock->control, &rFd) && !read_from_socket(dsock))
socket.c:      if (dsock->next_command[0] != '\0')
socket.c:        switch(dsock->state)
socket.c:              bug( "Invalid state: %i", dsock->state );
socket.c:              handle_new_connections(dsock, dsock->next_command);
socket.c:              handle_cmd_input(dsock, dsock->next_command);
socket.c:        dsock->next_command[0] = '\0';
socket.c:      if (dsock->state == STATE_CLOSED) continue;
socket.c:    usecs = (int) (last_time.tv_usec -  new_time.tv_usec) + 1000000 / PULSES_PER_SECOND;
socket.c:    secs  = (int) (last_time.tv_sec  -  new_time.tv_sec);
socket.c:      secs  -= 1;
socket.c:      usecs -= 1000000;
socket.c:  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) == -1)
socket.c:  /* set the socket as non-blocking */
socket.c:    sock_new->hostname = strdup("unknown");
socket.c:    sock_new->hostname = strdup(inet_ntoa(sock_addr.sin_addr));
socket.c:    if (strcasecmp(sock_new->hostname, "127.0.0.1"))
socket.c:      lData->buf    =  strdup((char *) &sock_addr.sin_addr);
socket.c:      lData->dsock  =  sock_new;
socket.c:    else sock_new->lookup_status++;
socket.c:  if (dsock->lookup_status > TSTATE_DONE) return;
socket.c:  dsock->lookup_status += 2;
socket.c:  FD_CLR(dsock->control, &fSet);
socket.c:  if (dsock->state == STATE_PLAYING)
socket.c:    else if (dsock->player)
socket.c:      dsock->player->socket = NULL;
socket.c:      log_string("Closing link to %s", dsock->player->name);
socket.c:  else if (dsock->player)
socket.c:    free_mobile(dsock->player);
socket.c:  AttachIterator(&Iter, dsock->events);
socket.c:  dsock->state = STATE_CLOSED;
socket.c:  size = strlen(dsock->inbuf);
socket.c:  if (size >= sizeof(dsock->inbuf) - 2)
socket.c:    int wanted = sizeof(dsock->inbuf) - 2 - size;
socket.c:    sInput = read(dsock->control, dsock->inbuf + size, wanted);
socket.c:      if (dsock->inbuf[size-1] == '\n' || dsock->inbuf[size-1] == '\r')
socket.c:  dsock->inbuf[size] = '\0';
socket.c:  if (dsock->next_command[0] != '\0')
socket.c:  if (dsock->inbuf[0] == '\0')
socket.c:  while (dsock->inbuf[size] != '\0' && dsock->inbuf[size] != '\n' && dsock->inbuf[size] != '\r')
socket.c:  if (dsock->inbuf[size] == '\0')
socket.c:    if (dsock->inbuf[i] == (signed char) IAC)
socket.c:    else if (telopt == 1 && (dsock->inbuf[i] == (signed char) DO || dsock->inbuf[i] == (signed char) DONT))
socket.c:      if (dsock->inbuf[i] == (signed char) TELOPT_COMPRESS)         /* check for version 1 */
socket.c:        if (dsock->inbuf[i-1] == (signed char) DO)                  /* start compressing   */
socket.c:        else if (dsock->inbuf[i-1] == (signed char) DONT)           /* stop compressing    */
socket.c:      else if (dsock->inbuf[i] == (signed char) TELOPT_COMPRESS2)   /* check for version 2 */
socket.c:        if (dsock->inbuf[i-1] == (signed char) DO)                  /* start compressing   */
socket.c:        else if (dsock->inbuf[i-1] == (signed char) DONT)           /* stop compressing    */
socket.c:    else if (isprint(dsock->inbuf[i]) && isascii(dsock->inbuf[i]))
socket.c:      dsock->next_command[j++] = dsock->inbuf[i];
socket.c:  dsock->next_command[j] = '\0';
socket.c:  while (dsock->inbuf[size] == '\n' || dsock->inbuf[size] == '\r')
socket.c:    dsock->bust_prompt = TRUE;   /* seems like a good place to check */
socket.c:  while (dsock->inbuf[size] != '\0')
socket.c:    dsock->inbuf[size - i] = dsock->inbuf[size];
socket.c:  dsock->inbuf[size - i] = '\0';
socket.c:  sock_new->control        =  sock;
socket.c:  sock_new->state          =  STATE_GET_ACCOUNT;
socket.c:  sock_new->lookup_status  =  TSTATE_LOOKUP;
socket.c:  sock_new->player         =  NULL;
socket.c:  sock_new->top_output     =  0;
socket.c:  sock_new->events         =  AllocList();
socket.c:  if( (from = gethostbyaddr(lData->buf, sizeof(lData->buf), AF_INET ) ) != NULL )
socket.c:     free( lData->dsock->hostname );
socket.c:     lData->dsock->hostname = strdup( from->h_name );
socket.c:  lData->dsock->lookup_status++;
socket.c:  free(lData->buf);
socket.c:    if (dsock->lookup_status != TSTATE_CLOSED) continue;
socket.c:    close(dsock->control);
socket.c:    free(dsock->hostname);
socket.c:    FreeList(dsock->events);
socket.c:    compressEnd(dsock, dsock->compressing, TRUE);
stack.c:  pStack->_pCells = NULL;
stack.c:  pStack->_iSize = 0;
stack.c:  while ((pCell = pStack->_pCells) != NULL)
stack.c:    pStack->_pCells = pCell->_pNext;
stack.c:  if ((pCell = pStack->_pCells) != NULL)
stack.c:    void *pContent = pCell->_pContent;
stack.c:    pStack->_pCells = pCell->_pNext;
stack.c:    pStack->_iSize--;
stack.c:  pCell->_pNext = pStack->_pCells;
stack.c:  pCell->_pContent = pContent;
stack.c:  pStack->_pCells = pCell;
stack.c:  pStack->_iSize++;
stack.c:  return pStack->_iSize;
strings.c:  buffer->size = size;
strings.c:  buffer->data = malloc(size);
strings.c:  buffer->len = 0;
strings.c:  if ((text_len + buffer->len + 1) > buffer->size)
strings.c:    new_size = buffer->size + text_len + 1;
strings.c:    memcpy(new_data, buffer->data, buffer->len);
strings.c:    free(buffer->data);
strings.c:    buffer->data = new_data;  
strings.c:    buffer->size = new_size;
strings.c:  memcpy(buffer->data + buffer->len, text, text_len);
strings.c:  buffer->len += text_len;
strings.c:  buffer->data[buffer->len] = '\0';
strings.c:  free(buffer->data);
strings.c:  buffer->len = 0;
strings.c:  buffer->data[0] = '\0';
strings.c:  if (res >= MAX_BUFFER - 1)  
strings.c:    return -110;
strings.c:    return -1;
utils.c:  dMob->name         =  NULL;
utils.c:  dMob->password     =  NULL;
utils.c:  dMob->level        =  LEVEL_PLAYER;
utils.c:  dMob->events       =  AllocList();
utils.c:  if (dMob->socket) dMob->socket->player = NULL;
utils.c:  AttachIterator(&Iter, dMob->events);
utils.c:  FreeList(dMob->events);
utils.c:  free(dMob->name);
utils.c:  free(dMob->password);
utils.c:/* Recover from a copyover - load players */
utils.c:  /* In case something crashes - doesn't prevent reading */
utils.c:    if (desc == -1)
utils.c:    dsock->hostname     =  strdup(host);
utils.c:      dMob->socket     =  dsock;
utils.c:      dsock->player    =  dMob;
utils.c:    /* Write something, and check if it goes error-free */
utils.c:    dsock->bust_prompt    =  TRUE;
utils.c:    dsock->lookup_status  =  TSTATE_DONE;
utils.c:    dsock->state          =  STATE_PLAYING;
utils.c:    if (!strcasecmp(dMob->name, player))
utils.c:      if (dMob->socket)
utils.c:        close_socket(dMob->socket, TRUE);
